/**
 * OMS Nest Kubernetes Deployment Pipeline
 *
 * Jenkins parameterized pipeline for deploying to staging or production.
 * Triggered by GitHub Actions after successful CI builds.
 *
 * Jenkins jobs:
 *   - oms-nest-deploy-staging:    auto-deploy on develop merges
 *   - oms-nest-deploy-production: manual approval gate on main merges
 *
 * Required Jenkins credentials (store in Jenkins Credential Manager):
 *   - kubeconfig-oms:              Kubernetes cluster kubeconfig (Secret file)
 *   - ghcr-credentials:            GitHub Container Registry PAT (Username/Password)
 *   - slack-webhook-url:           Slack notification webhook (Secret text)
 *   - oms-db-credentials:          Database username/password (Username/Password)
 *   - oms-jwt-secret:              JWT signing secret (Secret text)
 *   - oms-redis-password:          Redis password (Secret text)
 *   - oms-encryption-secret:       Encryption key (Secret text)
 *   - oms-mail-credentials:        Mail SMTP username/password (Username/Password)
 *
 * Security hardening:
 *   - All secrets accessed via credentials() bindings (never hardcoded)
 *   - Secrets masked in build logs automatically by Jenkins
 *   - Workspace cleaned after every build
 *   - No secret values printed in echo/sh steps
 *   - Helm secrets passed via --set-string to avoid YAML injection
 */

pipeline {
    agent any

    parameters {
        string(name: 'BACKEND_IMAGE_TAG', defaultValue: 'latest', description: 'Backend Docker image tag')
        string(name: 'FRONTEND_IMAGE_TAG', defaultValue: 'latest', description: 'Frontend Docker image tag')
        choice(name: 'ENVIRONMENT', choices: ['staging', 'production'], description: 'Target deployment environment')
    }

    environment {
        KUBECONFIG = credentials('kubeconfig-oms')
        HELM_CHART_PATH = 'kube/helm/oms-nest'
        SLACK_WEBHOOK = credentials('slack-webhook-url')
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '20'))
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Validate') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"
                    def valuesFile = "kube/helm/oms-nest/values-${params.ENVIRONMENT}.yaml"

                    echo "Deploying to ${params.ENVIRONMENT}"
                    echo "  Backend:  ${params.BACKEND_IMAGE_TAG}"
                    echo "  Frontend: ${params.FRONTEND_IMAGE_TAG}"
                    echo "  Namespace: ${namespace}"

                    // Validate Helm chart
                    sh """
                        helm lint ${HELM_CHART_PATH} -f ${valuesFile}
                    """

                    // Dry-run template rendering
                    sh """
                        helm template oms-nest-${params.ENVIRONMENT} ${HELM_CHART_PATH} \
                            -f ${valuesFile} \
                            --set backend.image.tag=${params.BACKEND_IMAGE_TAG} \
                            --set frontend.image.tag=${params.FRONTEND_IMAGE_TAG} \
                            -n ${namespace} \
                            > /dev/null
                    """
                }
            }
        }

        stage('Approval Gate') {
            when {
                expression { params.ENVIRONMENT == 'production' }
            }
            steps {
                script {
                    slackSend(
                        color: '#FFA500',
                        message: ":warning: *OMS Nest Production Deploy* awaiting approval\nBackend: `${params.BACKEND_IMAGE_TAG}` | Frontend: `${params.FRONTEND_IMAGE_TAG}`\n<${env.BUILD_URL}|Approve/Reject>",
                        channel: '#oms-deployments'
                    )
                }
                timeout(time: 15, unit: 'MINUTES') {
                    input message: "Deploy to PRODUCTION?",
                          ok: "Deploy",
                          submitter: "admin,devops"
                }
            }
        }

        stage('Setup Namespace') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"

                    sh """
                        kubectl create namespace ${namespace} --dry-run=client -o yaml | kubectl apply -f -
                        kubectl label namespace ${namespace} environment=${params.ENVIRONMENT} --overwrite
                    """
                }
            }
        }

        stage('Sync Secrets') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"

                    // Use Jenkins withCredentials to bind secrets securely.
                    // Jenkins automatically masks these values in build logs.
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'oms-db-credentials',
                            usernameVariable: 'DB_USER',
                            passwordVariable: 'DB_PASS'
                        ),
                        string(credentialsId: 'oms-jwt-secret', variable: 'JWT_SECRET'),
                        string(credentialsId: 'oms-encryption-secret', variable: 'ENCRYPTION_SECRET'),
                        string(credentialsId: 'oms-redis-password', variable: 'REDIS_PASS'),
                        usernamePassword(
                            credentialsId: 'oms-mail-credentials',
                            usernameVariable: 'MAIL_USER',
                            passwordVariable: 'MAIL_PASS'
                        ),
                        usernamePassword(
                            credentialsId: 'ghcr-credentials',
                            usernameVariable: 'GHCR_USER',
                            passwordVariable: 'GHCR_TOKEN'
                        )
                    ]) {
                        // Create/update application secrets in Kubernetes.
                        // Values are injected from Jenkins credentials and automatically
                        // masked in console output. The --dry-run | apply pattern
                        // is idempotent (safe to re-run).
                        sh '''
                            set +x
                            kubectl create secret generic oms-nest-secrets \
                                --namespace="${namespace}" \
                                --from-literal=DATABASE_USERNAME="${DB_USER}" \
                                --from-literal=DATABASE_PASSWORD="${DB_PASS}" \
                                --from-literal=AUTH_JWT_SECRET="${JWT_SECRET}" \
                                --from-literal=AUTH_REFRESH_SECRET="${JWT_SECRET}" \
                                --from-literal=ENCRYPTION_SECRET="${ENCRYPTION_SECRET}" \
                                --from-literal=REDIS_PASSWORD="${REDIS_PASS}" \
                                --from-literal=MAIL_USER="${MAIL_USER}" \
                                --from-literal=MAIL_PASSWORD="${MAIL_PASS}" \
                                --dry-run=client -o yaml | kubectl apply -f -

                            kubectl create secret docker-registry ghcr-credentials \
                                --namespace="${namespace}" \
                                --docker-server=ghcr.io \
                                --docker-username="${GHCR_USER}" \
                                --docker-password="${GHCR_TOKEN}" \
                                --dry-run=client -o yaml | kubectl apply -f -
                        '''
                    }

                    echo "Kubernetes secrets synced for namespace: ${namespace}"
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"
                    def releaseName = "oms-nest-${params.ENVIRONMENT}"
                    def valuesFile = "kube/helm/oms-nest/values-${params.ENVIRONMENT}.yaml"

                    sh """
                        helm upgrade --install ${releaseName} ${HELM_CHART_PATH} \
                            -f ${valuesFile} \
                            --set backend.image.tag=${params.BACKEND_IMAGE_TAG} \
                            --set frontend.image.tag=${params.FRONTEND_IMAGE_TAG} \
                            -n ${namespace} \
                            --atomic \
                            --wait \
                            --timeout 10m
                    """
                }
            }
        }

        stage('Verify Secrets') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"

                    // Verify secrets exist without printing values
                    sh """
                        echo "Verifying secrets in namespace ${namespace}..."
                        kubectl get secret oms-nest-secrets -n ${namespace} \
                            -o jsonpath='{.metadata.name}' && echo " [OK]"
                        kubectl get secret ghcr-credentials -n ${namespace} \
                            -o jsonpath='{.metadata.name}' && echo " [OK]"
                    """
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    def namespace = "oms-nest-${params.ENVIRONMENT}"

                    // Wait for pods to be ready
                    sh """
                        kubectl rollout status deployment/oms-nest-${params.ENVIRONMENT}-backend \
                            -n ${namespace} --timeout=300s

                        kubectl rollout status deployment/oms-nest-${params.ENVIRONMENT}-frontend \
                            -n ${namespace} --timeout=300s
                    """

                    // Verify health endpoints
                    sh """
                        kubectl exec deployment/oms-nest-${params.ENVIRONMENT}-backend \
                            -n ${namespace} -- \
                            wget -q -O- http://localhost:3001/health || exit 1

                        kubectl exec deployment/oms-nest-${params.ENVIRONMENT}-backend \
                            -n ${namespace} -- \
                            wget -q -O- http://localhost:3001/health/ready || exit 1
                    """

                    echo "Health checks passed"
                }
            }
        }
    }

    post {
        success {
            slackSend(
                color: 'good',
                message: ":white_check_mark: *OMS Nest ${params.ENVIRONMENT}* deployed successfully\nBackend: `${params.BACKEND_IMAGE_TAG}` | Frontend: `${params.FRONTEND_IMAGE_TAG}`\nBuild: <${env.BUILD_URL}|#${env.BUILD_NUMBER}>",
                channel: '#oms-deployments'
            )
        }
        failure {
            slackSend(
                color: 'danger',
                message: ":x: *OMS Nest ${params.ENVIRONMENT}* deployment FAILED\nBackend: `${params.BACKEND_IMAGE_TAG}` | Frontend: `${params.FRONTEND_IMAGE_TAG}`\nBuild: <${env.BUILD_URL}|#${env.BUILD_NUMBER}>",
                channel: '#oms-deployments'
            )
        }
        always {
            cleanWs()
        }
    }
}
