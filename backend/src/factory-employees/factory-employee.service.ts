import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
  Inject,
} from "@nestjs/common";
import { FactoryEmployee } from "./domain/factory-employee";
import { FactoryEmployeeId } from "./domain/value-objects/factory-employee-id.value-object";
import { FactoryEmployeeRepository } from "./domain/factory-employee.repository";
import { CreateFactoryEmployeeDto } from "./dto/create-factory-employee.dto";
import { UpdateFactoryEmployeeDto } from "./dto/update-factory-employee.dto";
import { QueryFactoryEmployeeDto } from "./dto/query-factory-employee.dto";
import { FactoryEmployeeDtoMapper } from "./mappers/factory-employee-dto.mapper";

/**
 * Factory Employee Service
 * Handles business logic for factory employee operations
 */
@Injectable()
export class FactoryEmployeeService {
  constructor(
    @Inject("FactoryEmployeeRepository")
    private readonly factoryEmployeeRepository: FactoryEmployeeRepository,
  ) {}

  /**
   * Create a new factory employee
   */
  async create(
    createFactoryEmployeeDto: CreateFactoryEmployeeDto,
  ): Promise<FactoryEmployee> {
    const { factoryId, name } = createFactoryEmployeeDto;

    // Validate business rules
    await this.validateFactoryEmployeeCreation(factoryId, name);

    // Check for duplicate name within the same factory
    const existingEmployee =
      await this.factoryEmployeeRepository.existsByNameAndFactory(
        name,
        factoryId,
      );

    if (existingEmployee) {
      throw new ConflictException(
        `Employee with name '${name}' already exists in factory ${factoryId}`,
      );
    }

    // Create domain entity without ID (will be generated by database)
    // Use a temporary ID of 0 which will be replaced after persistence
    const tempId = FactoryEmployeeId.fromNumber(0);
    const factoryEmployee = new FactoryEmployee(tempId, factoryId, name);

    // Save to repository
    const savedEmployee =
      await this.factoryEmployeeRepository.save(factoryEmployee);

    return savedEmployee;
  }

  /**
   * Find all factory employees with optional filters
   */
  async findAll(query: QueryFactoryEmployeeDto): Promise<{
    data: FactoryEmployee[];
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  }> {
    const { limit, offset } =
      FactoryEmployeeDtoMapper.mapPaginationParams(query);

    const filters = {
      factoryId: query.factoryId,
      name: query.name,
      limit,
      offset,
    };

    // Get data and total count in parallel
    const [data, total] = await Promise.all([
      this.factoryEmployeeRepository.findAll(filters),
      this.factoryEmployeeRepository.count({
        factoryId: query.factoryId,
        name: query.name,
      }),
    ]);

    const page = query.page || Math.floor(offset / limit) + 1;
    const totalPages = Math.ceil(total / limit);

    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  }

  /**
   * Find factory employee by ID
   */
  async findOne(id: number): Promise<FactoryEmployee> {
    const factoryEmployeeId = FactoryEmployeeId.fromNumber(id);
    const factoryEmployee =
      await this.factoryEmployeeRepository.findById(factoryEmployeeId);

    if (!factoryEmployee) {
      throw new NotFoundException(`Factory Employee with ID ${id} not found`);
    }

    return factoryEmployee;
  }

  /**
   * Find factory employees by factory ID
   */
  async findByFactoryId(factoryId: number): Promise<FactoryEmployee[]> {
    if (!factoryId || factoryId <= 0) {
      throw new BadRequestException("Factory ID must be a positive number");
    }

    return this.factoryEmployeeRepository.findByFactoryId(factoryId);
  }

  /**
   * Update factory employee
   */
  async update(
    id: number,
    updateFactoryEmployeeDto: UpdateFactoryEmployeeDto,
  ): Promise<FactoryEmployee> {
    const factoryEmployeeId = FactoryEmployeeId.fromNumber(id);

    // Check if employee exists
    const existingEmployee =
      await this.factoryEmployeeRepository.findById(factoryEmployeeId);
    if (!existingEmployee) {
      throw new NotFoundException(`Factory Employee with ID ${id} not found`);
    }

    // Validate updates
    if (updateFactoryEmployeeDto.factoryId !== undefined) {
      await this.validateFactoryExists(updateFactoryEmployeeDto.factoryId);
    }

    // Check for name conflicts within the factory
    if (updateFactoryEmployeeDto.name !== undefined) {
      const targetFactoryId =
        updateFactoryEmployeeDto.factoryId || existingEmployee.factoryId;
      const existingWithName =
        await this.factoryEmployeeRepository.existsByNameAndFactory(
          updateFactoryEmployeeDto.name,
          targetFactoryId,
        );

      if (
        existingWithName &&
        updateFactoryEmployeeDto.name !== existingEmployee.name
      ) {
        throw new ConflictException(
          `Employee with name '${updateFactoryEmployeeDto.name}' already exists in factory ${targetFactoryId}`,
        );
      }
    }

    const updates = FactoryEmployeeDtoMapper.fromUpdateDto(
      updateFactoryEmployeeDto,
    );

    return this.factoryEmployeeRepository.update(factoryEmployeeId, updates);
  }

  /**
   * Delete factory employee
   */
  async remove(id: number): Promise<void> {
    const factoryEmployeeId = FactoryEmployeeId.fromNumber(id);

    // Check if employee exists
    const exists =
      await this.factoryEmployeeRepository.exists(factoryEmployeeId);
    if (!exists) {
      throw new NotFoundException(`Factory Employee with ID ${id} not found`);
    }

    await this.factoryEmployeeRepository.delete(factoryEmployeeId);
  }

  /**
   * Get employee count by factory
   */
  async getEmployeeCountByFactory(factoryId: number): Promise<number> {
    if (!factoryId || factoryId <= 0) {
      throw new BadRequestException("Factory ID must be a positive number");
    }

    return this.factoryEmployeeRepository.count({ factoryId });
  }

  /**
   * Check if employee exists
   */
  async exists(id: number): Promise<boolean> {
    const factoryEmployeeId = FactoryEmployeeId.fromNumber(id);
    return this.factoryEmployeeRepository.exists(factoryEmployeeId);
  }

  /**
   * Bulk transfer employees to another factory
   */
  async bulkTransferToFactory(
    employeeIds: number[],
    newFactoryId: number,
  ): Promise<FactoryEmployee[]> {
    if (!employeeIds || employeeIds.length === 0) {
      throw new BadRequestException("Employee IDs cannot be empty");
    }

    if (!newFactoryId || newFactoryId <= 0) {
      throw new BadRequestException("Factory ID must be a positive number");
    }

    // Validate factory exists
    await this.validateFactoryExists(newFactoryId);

    const updatedEmployees: FactoryEmployee[] = [];

    for (const employeeId of employeeIds) {
      try {
        const updated = await this.update(employeeId, {
          factoryId: newFactoryId,
        });
        updatedEmployees.push(updated);
      } catch (error) {
        // Continue with other employees if one fails
        console.warn(
          `Failed to transfer employee ${employeeId}: ${error.message}`,
        );
      }
    }

    return updatedEmployees;
  }

  /**
   * Private helper methods
   */

  private async validateFactoryEmployeeCreation(
    factoryId: number,
    name: string,
  ): Promise<void> {
    if (!factoryId || factoryId <= 0) {
      throw new BadRequestException("Factory ID must be a positive number");
    }

    if (!name || name.trim().length === 0) {
      throw new BadRequestException("Employee name cannot be empty");
    }

    if (name.trim().length > 255) {
      throw new BadRequestException(
        "Employee name cannot exceed 255 characters",
      );
    }

    // Validate factory exists
    await this.validateFactoryExists(factoryId);
  }

  private async validateFactoryExists(factoryId: number): Promise<void> {
    await Promise.resolve();
    // TODO: Implement factory existence check when FactoryService is available
    // For now, we assume the factory exists
    // This should be implemented when the relationship is fully established
    if (!factoryId || factoryId <= 0) {
      throw new BadRequestException("Invalid factory ID");
    }
  }
}
