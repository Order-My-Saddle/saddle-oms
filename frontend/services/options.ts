import { fetchEntities } from './api';
import { logger } from '@/utils/logger';

export interface Option {
  id: string;
  name: string;
  sequence?: number;
  active?: boolean;
  price?: number;
  description?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface OptionsResponse {
  'hydra:member': Option[];
  'hydra:totalItems': number;
  'hydra:view'?: {
    '@id': string;
    'hydra:first'?: string;
    'hydra:last'?: string;
    'hydra:next'?: string;
    'hydra:previous'?: string;
  };
}

export async function fetchOptions({
  page = 1,
  searchTerm = '',
  filters = {},
  orderBy = 'sequence',
  order = 'asc'
}: {
  page?: number;
  searchTerm?: string;
  filters?: Record<string, string>;
  orderBy?: string;
  order?: 'asc' | 'desc';
} = {}): Promise<OptionsResponse> {
  logger.log('fetchOptions: Called with params:', { page, searchTerm, filters, orderBy, order });
  
  // Build filter parameters for API Platform
  const extraParams: Record<string, string | number | boolean> = {};
  
  // Handle individual field filters
  Object.entries(filters).forEach(([key, value]) => {
    if (value && value.trim()) {
      logger.log(`fetchOptions: Processing filter ${key}:`, value);
      // For text fields, use partial matching with API Platform filters
      if (key === 'name') {
        extraParams['name[contains]'] = value;
      } else if (key === 'description') {
        extraParams['description[contains]'] = value;
      } else if (key === 'active') {
        extraParams['active'] = value === 'true';
      } else if (key === 'sequence') {
        extraParams['sequence'] = parseInt(value);
      } else if (key === 'price') {
        extraParams['price'] = parseFloat(value);
      }
      // For other exact matches
      else {
        extraParams[key] = value;
      }
    }
  });

  logger.log('fetchOptions: Calling fetchEntities with entity "options" and params:', extraParams);

  return await fetchEntities({
    entity: 'options',
    page,
    partial: false, // Required for hydra:totalItems in API Platform 2.5.7
    searchTerm,
    orderBy,
    order,
    extraParams
  });
}

function getToken() {
  if (typeof window !== 'undefined') {
    // Try to get token from auth_token first (Jotai store)
    try {
      const stored = localStorage.getItem('auth_token');
      if (stored && stored !== 'null') {
        const parsedToken = JSON.parse(stored);
        return parsedToken;
      }
    } catch (e) {
      // Fallback to token key
    }

    // Check localStorage for 'token' key
    try {
      const token = localStorage.getItem('token');
      if (token && token !== 'null') {
        return token;
      }
    } catch (e) {
      // Continue to cookies
    }

    // Fallback to cookies
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === 'token') {
        return value;
      }
    }
  }
  return null;
}

export async function createOption(optionData: Partial<Option>): Promise<Option> {
  const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
  const token = getToken();

  // Create BreezeJS-style entity with the correct format for the backend
  const entity = {
    name: optionData.name,
    sequence: optionData.sequence || 0,
    active: optionData.active ?? true,
    price: optionData.price,
    description: optionData.description,
    // BreezeJS entity metadata
    entityAspect: {
      entityTypeName: "Option:#App.Entity.Modelling",
      entityState: "Added",
      originalValuesMap: {},
      autoGeneratedKey: null,
      defaultResourceName: "options"
    }
  };

  // Remove undefined fields
  Object.keys(entity).forEach(key => {
    if (key !== 'entityAspect' && (entity as any)[key] === undefined) {
      delete (entity as any)[key];
    }
  });

  // Create the save bundle structure expected by the backend
  const saveBundle = {
    entities: [entity]
  };

  logger.log('Attempting option creation with BreezeJS SaveBundle:', JSON.stringify(saveBundle, null, 2));

  const response = await fetch(`${API_URL}/save`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/ld+json',
      'Accept': 'application/ld+json',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    },
    credentials: 'include',
    body: JSON.stringify(saveBundle),
  });

  if (!response.ok) {
    const errorText = await response.text();
    logger.error('Option creation failed:', errorText);
    throw new Error(`Failed to create option: ${response.statusText}`);
  }

  const result = await response.json();
  logger.log('Option creation result:', result);

  // Return the first entity from the response
  return result.Entities?.[0] || result.entities?.[0] || result;
}

export async function updateOption(id: string, optionData: Partial<Option>): Promise<Option> {
  const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
  const token = getToken();

  // Create BreezeJS-style entity with the correct format for the backend
  const entity = {
    id: id,
    name: optionData.name,
    sequence: optionData.sequence || 0,
    active: optionData.active ?? true,
    price: optionData.price,
    description: optionData.description,
    // BreezeJS entity metadata
    entityAspect: {
      entityTypeName: "Option:#App.Entity.Modelling",
      entityState: "Modified",
      originalValuesMap: {},
      autoGeneratedKey: null,
      defaultResourceName: "options"
    }
  };

  // Remove undefined fields
  Object.keys(entity).forEach(key => {
    if (key !== 'entityAspect' && (entity as any)[key] === undefined) {
      delete (entity as any)[key];
    }
  });

  // Create the save bundle structure expected by the backend
  const saveBundle = {
    entities: [entity]
  };

  logger.log('Attempting option update with BreezeJS SaveBundle:', JSON.stringify(saveBundle, null, 2));

  const response = await fetch(`${API_URL}/save`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/ld+json',
      'Accept': 'application/ld+json',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    },
    credentials: 'include',
    body: JSON.stringify(saveBundle),
  });

  if (!response.ok) {
    const errorText = await response.text();
    logger.error('Option update failed:', errorText);
    throw new Error(`Failed to update option: ${response.statusText}`);
  }

  const result = await response.json();
  logger.log('Option update result:', result);

  // Return the first entity from the response
  return result.Entities?.[0] || result.entities?.[0] || result;
}

export async function deleteOption(id: string): Promise<void> {
  const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
  const token = getToken();

  const response = await fetch(`${API_URL}/options/${id}`, {
    method: 'DELETE',
    headers: {
      'Accept': 'application/ld+json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    },
    credentials: 'include',
  });

  if (!response.ok) {
    throw new Error(`Failed to delete option: ${response.statusText}`);
  }
}

/**
 * Get the total count of options (for pagination display)
 */
export async function fetchOptionCount(): Promise<number> {
  try {
    logger.log('ðŸ“Š fetchOptionCount: Getting total option count');

    // Get total count using minimal data transfer (limit=1) with full pagination metadata
    const result = await fetchEntities({
      entity: 'options',
      page: 1,
      partial: false, // Required for hydra:totalItems in API Platform 2.5.7
      extraParams: {
        'limit': 1, // Minimize data transfer
      },
    });

    // Return the total count if available
    if (result['hydra:totalItems'] !== undefined && result['hydra:totalItems'] !== null) {
      logger.log('ðŸ“Š Got total option count from API:', result['hydra:totalItems']);
      return result['hydra:totalItems'];
    }

    logger.warn('ðŸ“Š Could not get option count from API, using fallback');
    return 0;
  } catch (error) {
    logger.error('ðŸ“Š Error fetching option count:', error);
    return 0;
  }
}